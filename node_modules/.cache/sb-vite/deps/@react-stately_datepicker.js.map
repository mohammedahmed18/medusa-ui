{
  "version": 3,
  "sources": ["../../../../../../../node_modules/@react-stately/overlays/dist/packages/@react-stately/overlays/src/index.ts", "../../../../../../../node_modules/@react-stately/overlays/dist/packages/@react-stately/overlays/src/useOverlayTriggerState.ts", "../../../../../../../node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/index.ts", "../../../../../../../node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDatePickerState.ts", "../../../../../../../node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/utils.ts", "../../../../../../../node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDateFieldState.ts", "../../../../../../../node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/placeholders.ts", "../../../../../../../node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useDateRangePickerState.ts", "../../../../../../../node_modules/@react-stately/datepicker/dist/packages/@react-stately/datepicker/src/useTimeFieldState.ts"],
  "sourcesContent": ["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useOverlayTriggerState} from './useOverlayTriggerState';\n\nexport type {OverlayTriggerProps} from '@react-types/overlays';\nexport type {OverlayTriggerState} from './useOverlayTriggerState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {OverlayTriggerProps} from '@react-types/overlays';\nimport {useCallback} from 'react';\nimport {useControlledState} from '@react-stately/utils';\n\nexport interface OverlayTriggerState {\n  /** Whether the overlay is currently open. */\n  readonly isOpen: boolean,\n  /** Sets whether the overlay is open. */\n  setOpen(isOpen: boolean): void,\n  /** Opens the overlay. */\n  open(): void,\n  /** Closes the overlay. */\n  close(): void,\n  /** Toggles the overlay's visibility. */\n  toggle(): void\n}\n\n/**\n * Manages state for an overlay trigger. Tracks whether the overlay is open, and provides\n * methods to toggle this state.\n */\nexport function useOverlayTriggerState(props: OverlayTriggerProps): OverlayTriggerState  {\n  let [isOpen, setOpen] = useControlledState(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n\n  const open = useCallback(() => {\n    setOpen(true);\n  }, [setOpen]);\n\n  const close = useCallback(() => {\n    setOpen(false);\n  }, [setOpen]);\n\n  const toggle = useCallback(() => {\n    setOpen(!isOpen);\n  }, [setOpen, isOpen]);\n\n  return {\n    isOpen,\n    setOpen,\n    open,\n    close,\n    toggle\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport {useDatePickerState} from './useDatePickerState';\nexport {useDateFieldState} from './useDateFieldState';\nexport {useDateRangePickerState} from './useDateRangePickerState';\nexport {useTimeFieldState} from './useTimeFieldState';\n\nexport type {DateFieldStateOptions, DateFieldState, DateSegment, SegmentType} from './useDateFieldState';\nexport type {DatePickerStateOptions, DatePickerState} from './useDatePickerState';\nexport type {DateRangePickerStateOptions, DateRangePickerState} from './useDateRangePickerState';\nexport type {TimeFieldStateOptions, TimeFieldState} from './useTimeFieldState';\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CalendarDate, DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DatePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, getFormatOptions, getPlaceholderTime, isInvalid, useDefaultProps} from './utils';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {useControlledState} from '@react-stately/utils';\nimport {useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport interface DatePickerStateOptions<T extends DateValue> extends DatePickerProps<T> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\nexport interface DatePickerState extends OverlayTriggerState {\n  /** The currently selected date. */\n  value: DateValue,\n  /** Sets the selected date. */\n  setValue(value: DateValue): void,\n  /**\n   * The date portion of the value. This may be set prior to `value` if the user has\n   * selected a date but has not yet selected a time.\n   */\n  dateValue: DateValue,\n  /** Sets the date portion of the value. */\n  setDateValue(value: CalendarDate): void,\n  /**\n   * The time portion of the value. This may be set prior to `value` if the user has\n   * selected a time but has not yet selected a date.\n   */\n  timeValue: TimeValue,\n  /** Sets the time portion of the value. */\n  setTimeValue(value: TimeValue): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date picker supports selecting a time, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /** The current validation state of the date picker, based on the `validationState`, `minValue`, and `maxValue` props. */\n  validationState: ValidationState,\n  /** Formats the selected value using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): string\n}\n\n/**\n * Provides state management for a date picker component.\n * A date picker combines a DateField and a Calendar popover to allow users to enter or select a date and time value.\n */\nexport function useDatePickerState<T extends DateValue = DateValue>(props: DatePickerStateOptions<T>): DatePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [value, setValue] = useControlledState<DateValue>(props.value, props.defaultValue || null, props.onChange);\n\n  let v = (value || props.placeholderValue);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let dateValue = value != null ? value.toDate(defaultTimeZone ?? 'UTC') : null;\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [selectedDate, setSelectedDate] = useState<DateValue>(null);\n  let [selectedTime, setSelectedTime] = useState<TimeValue>(null);\n\n  if (value) {\n    selectedDate = value;\n    if ('hour' in value) {\n      selectedTime = value;\n    }\n  }\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let commitValue = (date: DateValue, time: TimeValue) => {\n    setValue('timeZone' in time ? time.set(toCalendarDate(date)) : toCalendarDateTime(date, time));\n    setSelectedDate(null);\n    setSelectedTime(null);\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let selectDate = (newValue: CalendarDate) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (selectedTime || shouldClose) {\n        commitValue(newValue, selectedTime || getPlaceholderTime(props.placeholderValue));\n      } else {\n        setSelectedDate(newValue);\n      }\n    } else {\n      setValue(newValue);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let selectTime = (newValue: TimeValue) => {\n    if (selectedDate && newValue) {\n      commitValue(selectedDate, newValue);\n    } else {\n      setSelectedTime(newValue);\n    }\n  };\n\n  let validationState: ValidationState = props.validationState ||\n    (isInvalid(value, props.minValue, props.maxValue) ? 'invalid' : null) ||\n    (value && props.isDateUnavailable?.(value) ? 'invalid' : null);\n\n  return {\n    value,\n    setValue,\n    dateValue: selectedDate,\n    timeValue: selectedTime,\n    setDateValue: selectDate,\n    setTimeValue: selectTime,\n    granularity,\n    hasTime,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time was set and not the date, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !value && selectedDate && hasTime) {\n        commitValue(selectedDate, selectedTime || getPlaceholderTime(props.placeholderValue));\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    formatValue(locale, fieldOptions) {\n      if (!dateValue) {\n        return '';\n      }\n\n      let formatOptions = getFormatOptions(fieldOptions, {\n        granularity,\n        timeZone: defaultTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: value.calendar.identifier === 'gregory' && value.era === 'BC'\n      });\n\n      let formatter = new DateFormatter(locale, formatOptions);\n      return formatter.format(dateValue);\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, now, Time, toCalendar, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DatePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {useState} from 'react';\n\nexport function isInvalid(value: DateValue, minValue: DateValue, maxValue: DateValue) {\n  return value != null && (\n    (minValue != null && value.compare(minValue) < 0) ||\n    (maxValue != null && value.compare(maxValue) > 0)\n  );\n}\n\nexport type FieldOptions = Pick<Intl.DateTimeFormatOptions, 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second'>;\ninterface FormatterOptions {\n  timeZone?: string,\n  hideTimeZone?: boolean,\n  granularity?: DatePickerProps<any>['granularity'],\n  maxGranularity?: 'year' | 'month' | DatePickerProps<any>['granularity'],\n  hourCycle?: 12 | 24,\n  showEra?: boolean,\n  shouldForceLeadingZeros?: boolean\n}\n\nconst DEFAULT_FIELD_OPTIONS: FieldOptions = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: '2-digit',\n  second: '2-digit'\n};\n\nconst TWO_DIGIT_FIELD_OPTIONS: FieldOptions = {\n  year: 'numeric',\n  month: '2-digit',\n  day: '2-digit',\n  hour: '2-digit',\n  minute: '2-digit',\n  second: '2-digit'\n};\n\nexport function getFormatOptions(\n  fieldOptions: FieldOptions,\n  options: FormatterOptions\n): Intl.DateTimeFormatOptions {\n  let defaultFieldOptions = options.shouldForceLeadingZeros ? TWO_DIGIT_FIELD_OPTIONS : DEFAULT_FIELD_OPTIONS;\n  fieldOptions = {...defaultFieldOptions, ...fieldOptions};\n  let granularity = options.granularity || 'minute';\n  let keys = Object.keys(fieldOptions);\n  let startIdx = keys.indexOf(options.maxGranularity ?? 'year');\n  if (startIdx < 0) {\n    startIdx = 0;\n  }\n\n  let endIdx = keys.indexOf(granularity);\n  if (endIdx < 0) {\n    endIdx = 2;\n  }\n\n  if (startIdx > endIdx) {\n    throw new Error('maxGranularity must be greater than granularity');\n  }\n\n  let opts: Intl.DateTimeFormatOptions = keys.slice(startIdx, endIdx + 1).reduce((opts, key) => {\n    opts[key] = fieldOptions[key];\n    return opts;\n  }, {});\n\n  if (options.hourCycle != null) {\n    opts.hour12 = options.hourCycle === 12;\n  }\n\n  opts.timeZone = options.timeZone || 'UTC';\n\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  if (hasTime && options.timeZone && !options.hideTimeZone) {\n    opts.timeZoneName = 'short';\n  }\n\n  if (options.showEra && startIdx === 0) {\n    opts.era = 'short';\n  }\n\n  return opts;\n}\n\nexport function getPlaceholderTime(placeholderValue: DateValue): TimeValue {\n  if (placeholderValue && 'hour' in placeholderValue) {\n    return placeholderValue;\n  }\n\n  return new Time();\n}\n\nexport function convertValue(value: DateValue, calendar: Calendar): DateValue {\n  if (value === null) {\n    return null;\n  }\n\n  if (!value) {\n    return undefined;\n  }\n\n  return toCalendar(value, calendar);\n}\n\n\nexport function createPlaceholderDate(placeholderValue: DateValue, granularity: string, calendar: Calendar, timeZone: string) {\n  if (placeholderValue) {\n    return convertValue(placeholderValue, calendar);\n  }\n\n  let date = toCalendar(now(timeZone).set({\n    hour: 0,\n    minute: 0,\n    second: 0,\n    millisecond: 0\n  }), calendar);\n\n  if (granularity === 'year' || granularity === 'month' || granularity === 'day') {\n    return toCalendarDate(date);\n  }\n\n  if (!timeZone) {\n    return toCalendarDateTime(date);\n  }\n\n  return date;\n}\n\nexport function useDefaultProps(v: DateValue, granularity: Granularity): [Granularity, string] {\n  // Compute default granularity and time zone from the value. If the value becomes null, keep the last values.\n  let defaultTimeZone = (v && 'timeZone' in v ? v.timeZone : undefined);\n  let defaultGranularity: Granularity = (v && 'minute' in v ? 'minute' : 'day');\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && granularity && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let [lastValue, setLastValue] = useState<[Granularity, string]>([defaultGranularity, defaultTimeZone]);\n\n  // If the granularity or time zone changed, update the last value.\n  if (v && (lastValue[0] !== defaultGranularity || lastValue[1] !== defaultTimeZone)) {\n    setLastValue([defaultGranularity, defaultTimeZone]);\n  }\n\n  if (!granularity) {\n    granularity = v ? defaultGranularity : lastValue[0];\n  }\n\n  let timeZone = v ? defaultTimeZone : lastValue[1];\n  return [granularity, timeZone];\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Calendar, DateFormatter, getMinimumDayInMonth, getMinimumMonthInYear, GregorianCalendar, toCalendar} from '@internationalized/date';\nimport {convertValue, createPlaceholderDate, FieldOptions, getFormatOptions, isInvalid, useDefaultProps} from './utils';\nimport {DatePickerProps, DateValue, Granularity} from '@react-types/datepicker';\nimport {getPlaceholder} from './placeholders';\nimport {useControlledState} from '@react-stately/utils';\nimport {useEffect, useMemo, useRef, useState} from 'react';\nimport {ValidationState} from '@react-types/shared';\n\nexport type SegmentType = 'era' | 'year' | 'month' | 'day' |  'hour' | 'minute' | 'second' | 'dayPeriod' | 'literal' | 'timeZoneName';\nexport interface DateSegment {\n  /** The type of segment. */\n  type: SegmentType,\n  /** The formatted text for the segment. */\n  text: string,\n  /** The numeric value for the segment, if applicable. */\n  value?: number,\n  /** The minimum numeric value for the segment, if applicable. */\n  minValue?: number,\n  /** The maximum numeric value for the segment, if applicable. */\n  maxValue?: number,\n  /** Whether the value is a placeholder. */\n  isPlaceholder: boolean,\n  /** A placeholder string for the segment. */\n  placeholder: string,\n  /** Whether the segment is editable. */\n  isEditable: boolean\n}\n\nexport interface DateFieldState {\n  /** The current field value. */\n  value: DateValue,\n  /** The current value, converted to a native JavaScript `Date` object.  */\n  dateValue: Date,\n  /** The calendar system currently in use. */\n  calendar: Calendar,\n  /** Sets the field's value. */\n  setValue(value: DateValue): void,\n  /** A list of segments for the current value. */\n  segments: DateSegment[],\n  /** A date formatter configured for the current locale and format. */\n  dateFormatter: DateFormatter,\n  /** The current validation state of the date field, based on the `validationState`, `minValue`, and `maxValue` props. */\n  validationState: ValidationState,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** The maximum date or time unit that is displayed in the field. */\n  maxGranularity: 'year' | 'month' | Granularity,\n  /** Whether the field is disabled. */\n  isDisabled: boolean,\n  /** Whether the field is read only. */\n  isReadOnly: boolean,\n  /** Whether the field is required. */\n  isRequired: boolean,\n  /** Increments the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  increment(type: SegmentType): void,\n  /** Decrements the given segment. Upon reaching the minimum or maximum value, the value wraps around to the opposite limit. */\n  decrement(type: SegmentType): void,\n  /**\n   * Increments the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to increment by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  incrementPage(type: SegmentType): void,\n  /**\n   * Decrements the given segment by a larger amount, rounding it to the nearest increment.\n   * The amount to decrement by depends on the field, for example 15 minutes, 7 days, and 5 years.\n   * Upon reaching the minimum or maximum value, the value wraps around to the opposite limit.\n   */\n  decrementPage(type: SegmentType): void,\n  /** Sets the value of the given segment. */\n  setSegment(type: 'era', value: string): void,\n  setSegment(type: SegmentType, value: number): void,\n  /** Updates the remaining unfilled segments with the placeholder value. */\n  confirmPlaceholder(): void,\n  /** Clears the value of the given segment, reverting it to the placeholder. */\n  clearSegment(type: SegmentType): void,\n  /** Formats the current date value using the given options. */\n  formatValue(fieldOptions: FieldOptions): string\n}\n\nconst EDITABLE_SEGMENTS = {\n  year: true,\n  month: true,\n  day: true,\n  hour: true,\n  minute: true,\n  second: true,\n  dayPeriod: true,\n  era: true\n};\n\nconst PAGE_STEP = {\n  year: 5,\n  month: 2,\n  day: 7,\n  hour: 2,\n  minute: 15,\n  second: 15\n};\n\n// Node seems to convert everything to lowercase...\nconst TYPE_MAPPING = {\n  dayperiod: 'dayPeriod'\n};\n\nexport interface DateFieldStateOptions<T extends DateValue = DateValue> extends DatePickerProps<T> {\n  /**\n   * The maximum unit to display in the date field.\n   * @default 'year'\n   */\n  maxGranularity?: 'year' | 'month' | Granularity,\n  /** The locale to display and edit the value according to. */\n  locale: string,\n  /**\n   * A function that creates a [Calendar](../internationalized/date/Calendar.html)\n   * object for a given calendar identifier. Such a function may be imported from the\n   * `@internationalized/date` package, or manually implemented to include support for\n   * only certain calendars.\n   */\n  createCalendar: (name: string) => Calendar\n}\n\n/**\n * Provides state management for a date field component.\n * A date field allows users to enter and edit date and time values using a keyboard.\n * Each part of a date value is displayed in an individually editable segment.\n */\nexport function useDateFieldState<T extends DateValue = DateValue>(props: DateFieldStateOptions<T>): DateFieldState {\n  let {\n    locale,\n    createCalendar,\n    hideTimeZone,\n    isDisabled,\n    isReadOnly,\n    isRequired\n  } = props;\n\n  let v: DateValue = (props.value || props.defaultValue || props.placeholderValue);\n  let [granularity, defaultTimeZone] = useDefaultProps(v, props.granularity);\n  let timeZone = defaultTimeZone || 'UTC';\n\n  // props.granularity must actually exist in the value if one is provided.\n  if (v && !(granularity in v)) {\n    throw new Error('Invalid granularity ' + granularity + ' for value ' + v.toString());\n  }\n\n  let defaultFormatter = useMemo(() => new DateFormatter(locale), [locale]);\n  let calendar = useMemo(() => createCalendar(defaultFormatter.resolvedOptions().calendar), [createCalendar, defaultFormatter]);\n\n  let [value, setDate] = useControlledState<DateValue>(\n    props.value,\n    props.defaultValue,\n    props.onChange\n  );\n\n  let calendarValue = useMemo(() => convertValue(value, calendar), [value, calendar]);\n\n  // We keep track of the placeholder date separately in state so that onChange is not called\n  // until all segments are set. If the value === null (not undefined), then assume the component\n  // is controlled, so use the placeholder as the value until all segments are entered so it doesn't\n  // change from uncontrolled to controlled and emit a warning.\n  let [placeholderDate, setPlaceholderDate] = useState(\n    () => createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n  );\n\n  let val = calendarValue || placeholderDate;\n  let showEra = calendar.identifier === 'gregory' && val.era === 'BC';\n  let formatOpts = useMemo(() => ({\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    timeZone: defaultTimeZone,\n    hideTimeZone,\n    hourCycle: props.hourCycle,\n    showEra,\n    shouldForceLeadingZeros: props.shouldForceLeadingZeros\n  }), [props.maxGranularity, granularity, props.hourCycle, props.shouldForceLeadingZeros, defaultTimeZone, hideTimeZone, showEra]);\n  let opts = useMemo(() => getFormatOptions({}, formatOpts), [formatOpts]);\n\n  let dateFormatter = useMemo(() => new DateFormatter(locale, opts), [locale, opts]);\n  let resolvedOptions = useMemo(() => dateFormatter.resolvedOptions(), [dateFormatter]);\n\n  // Determine how many editable segments there are for validation purposes.\n  // The result is cached for performance.\n  let allSegments: Partial<typeof EDITABLE_SEGMENTS> = useMemo(() =>\n    dateFormatter.formatToParts(new Date())\n      .filter(seg => EDITABLE_SEGMENTS[seg.type])\n      .reduce((p, seg) => (p[seg.type] = true, p), {})\n  , [dateFormatter]);\n\n  let [validSegments, setValidSegments] = useState<Partial<typeof EDITABLE_SEGMENTS>>(\n    () => props.value || props.defaultValue ? {...allSegments} : {}\n  );\n\n  let clearedSegment = useRef<string>();\n\n  // Reset placeholder when calendar changes\n  let lastCalendarIdentifier = useRef(calendar.identifier);\n  useEffect(() => {\n    if (calendar.identifier !== lastCalendarIdentifier.current) {\n      lastCalendarIdentifier.current = calendar.identifier;\n      setPlaceholderDate(placeholder =>\n        Object.keys(validSegments).length > 0\n          ? toCalendar(placeholder, calendar)\n          : createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone)\n      );\n    }\n  }, [calendar, granularity, validSegments, defaultTimeZone, props.placeholderValue]);\n\n  // If there is a value prop, and some segments were previously placeholders, mark them all as valid.\n  if (value && Object.keys(validSegments).length < Object.keys(allSegments).length) {\n    validSegments = {...allSegments};\n    setValidSegments(validSegments);\n  }\n\n  // If the value is set to null and all segments are valid, reset the placeholder.\n  if (value == null && Object.keys(validSegments).length === Object.keys(allSegments).length) {\n    validSegments = {};\n    setValidSegments(validSegments);\n    setPlaceholderDate(createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone));\n  }\n\n  // If all segments are valid, use the date from state, otherwise use the placeholder date.\n  let displayValue = calendarValue && Object.keys(validSegments).length >= Object.keys(allSegments).length ? calendarValue : placeholderDate;\n  let setValue = (newValue: DateValue) => {\n    if (props.isDisabled || props.isReadOnly) {\n      return;\n    }\n    let validKeys = Object.keys(validSegments);\n    let allKeys = Object.keys(allSegments);\n\n    // if all the segments are completed or a timefield with everything but am/pm set the time, also ignore when am/pm cleared\n    if (newValue == null) {\n      setDate(null);\n      setPlaceholderDate(createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone));\n      setValidSegments({});\n    } else if (validKeys.length >= allKeys.length || (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod && clearedSegment.current !== 'dayPeriod')) {\n      // The display calendar should not have any effect on the emitted value.\n      // Emit dates in the same calendar as the original value, if any, otherwise gregorian.\n      newValue = toCalendar(newValue, v?.calendar || new GregorianCalendar());\n      setDate(newValue);\n    } else {\n      setPlaceholderDate(newValue);\n    }\n    clearedSegment.current = null;\n  };\n\n  let dateValue = useMemo(() => displayValue.toDate(timeZone), [displayValue, timeZone]);\n  let segments = useMemo(() =>\n    dateFormatter.formatToParts(dateValue)\n      .map(segment => {\n        let isEditable = EDITABLE_SEGMENTS[segment.type];\n        if (segment.type === 'era' && calendar.getEras().length === 1) {\n          isEditable = false;\n        }\n\n        let isPlaceholder = EDITABLE_SEGMENTS[segment.type] && !validSegments[segment.type];\n        let placeholder = EDITABLE_SEGMENTS[segment.type] ? getPlaceholder(segment.type, segment.value, locale) : null;\n        return {\n          type: TYPE_MAPPING[segment.type] || segment.type,\n          text: isPlaceholder ? placeholder : segment.value,\n          ...getSegmentLimits(displayValue, segment.type, resolvedOptions),\n          isPlaceholder,\n          placeholder,\n          isEditable\n        } as DateSegment;\n      })\n  , [dateValue, validSegments, dateFormatter, resolvedOptions, displayValue, calendar, locale]);\n\n  // When the era field appears, mark it valid if the year field is already valid.\n  // If the era field disappears, remove it from the valid segments.\n  if (allSegments.era && validSegments.year && !validSegments.era) {\n    validSegments.era = true;\n    setValidSegments({...validSegments});\n  } else if (!allSegments.era && validSegments.era) {\n    delete validSegments.era;\n    setValidSegments({...validSegments});\n  }\n\n  let markValid = (part: Intl.DateTimeFormatPartTypes) => {\n    validSegments[part] = true;\n    if (part === 'year' && allSegments.era) {\n      validSegments.era = true;\n    }\n    setValidSegments({...validSegments});\n  };\n\n  let adjustSegment = (type: Intl.DateTimeFormatPartTypes, amount: number) => {\n    if (!validSegments[type]) {\n      markValid(type);\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length >= allKeys.length || (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod)) {\n        setValue(displayValue);\n      }\n    } else {\n      setValue(addSegment(displayValue, type, amount, resolvedOptions));\n    }\n  };\n\n  let validationState: ValidationState = props.validationState ||\n    (isInvalid(calendarValue, props.minValue, props.maxValue) ? 'invalid' : null);\n\n  return {\n    value: calendarValue,\n    dateValue,\n    calendar,\n    setValue,\n    segments,\n    dateFormatter,\n    validationState,\n    granularity,\n    maxGranularity: props.maxGranularity ?? 'year',\n    isDisabled,\n    isReadOnly,\n    isRequired,\n    increment(part) {\n      adjustSegment(part, 1);\n    },\n    decrement(part) {\n      adjustSegment(part, -1);\n    },\n    incrementPage(part) {\n      adjustSegment(part, PAGE_STEP[part] || 1);\n    },\n    decrementPage(part) {\n      adjustSegment(part, -(PAGE_STEP[part] || 1));\n    },\n    setSegment(part, v) {\n      markValid(part);\n      setValue(setSegment(displayValue, part, v, resolvedOptions));\n    },\n    confirmPlaceholder() {\n      if (props.isDisabled || props.isReadOnly) {\n        return;\n      }\n\n      // Confirm the placeholder if only the day period is not filled in.\n      let validKeys = Object.keys(validSegments);\n      let allKeys = Object.keys(allSegments);\n      if (validKeys.length === allKeys.length - 1 && allSegments.dayPeriod && !validSegments.dayPeriod) {\n        validSegments = {...allSegments};\n        setValidSegments(validSegments);\n        setValue(displayValue.copy());\n      }\n    },\n    clearSegment(part) {\n      delete validSegments[part];\n      clearedSegment.current = part;\n      setValidSegments({...validSegments});\n\n      let placeholder = createPlaceholderDate(props.placeholderValue, granularity, calendar, defaultTimeZone);\n      let value = displayValue;\n\n      // Reset day period to default without changing the hour.\n      if (part === 'dayPeriod' && 'hour' in displayValue && 'hour' in placeholder) {\n        let isPM = displayValue.hour >= 12;\n        let shouldBePM = placeholder.hour >= 12;\n        if (isPM && !shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour - 12});\n        } else if (!isPM && shouldBePM) {\n          value = displayValue.set({hour: displayValue.hour + 12});\n        }\n      } else if (part in displayValue) {\n        value = displayValue.set({[part]: placeholder[part]});\n      }\n\n      setDate(null);\n      setValue(value);\n    },\n    formatValue(fieldOptions: FieldOptions) {\n      if (!calendarValue) {\n        return '';\n      }\n\n      let formatOptions = getFormatOptions(fieldOptions, formatOpts);\n      let formatter = new DateFormatter(locale, formatOptions);\n      return formatter.format(dateValue);\n    }\n  };\n}\n\nfunction getSegmentLimits(date: DateValue, type: string, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (type) {\n    case 'era': {\n      let eras = date.calendar.getEras();\n      return {\n        value: eras.indexOf(date.era),\n        minValue: 0,\n        maxValue: eras.length - 1\n      };\n    }\n    case 'year':\n      return {\n        value: date.year,\n        minValue: 1,\n        maxValue: date.calendar.getYearsInEra(date)\n      };\n    case 'month':\n      return {\n        value: date.month,\n        minValue: getMinimumMonthInYear(date),\n        maxValue: date.calendar.getMonthsInYear(date)\n      };\n    case 'day':\n      return {\n        value: date.day,\n        minValue: getMinimumDayInMonth(date),\n        maxValue: date.calendar.getDaysInMonth(date)\n      };\n  }\n\n  if ('hour' in date) {\n    switch (type) {\n      case 'dayPeriod':\n        return {\n          value: date.hour >= 12 ? 12 : 0,\n          minValue: 0,\n          maxValue: 12\n        };\n      case 'hour':\n        if (options.hour12) {\n          let isPM = date.hour >= 12;\n          return {\n            value: date.hour,\n            minValue: isPM ? 12 : 0,\n            maxValue: isPM ? 23 : 11\n          };\n        }\n\n        return {\n          value: date.hour,\n          minValue: 0,\n          maxValue: 23\n        };\n      case 'minute':\n        return {\n          value: date.minute,\n          minValue: 0,\n          maxValue: 59\n        };\n      case 'second':\n        return {\n          value: date.second,\n          minValue: 0,\n          maxValue: 59\n        };\n    }\n  }\n\n  return {};\n}\n\nfunction addSegment(value: DateValue, part: string, amount: number, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'era':\n    case 'year':\n    case 'month':\n    case 'day':\n      return value.cycle(part, amount, {round: part === 'year'});\n  }\n\n  if ('hour' in value) {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let isPM = hours >= 12;\n        return value.set({hour: isPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n      case 'minute':\n      case 'second':\n        return value.cycle(part, amount, {\n          round: part !== 'hour',\n          hourCycle: options.hour12 ? 12 : 24\n        });\n    }\n  }\n}\n\nfunction setSegment(value: DateValue, part: string, segmentValue: number, options: Intl.ResolvedDateTimeFormatOptions) {\n  switch (part) {\n    case 'day':\n    case 'month':\n    case 'year':\n    case 'era':\n      return value.set({[part]: segmentValue});\n  }\n\n  if ('hour' in value) {\n    switch (part) {\n      case 'dayPeriod': {\n        let hours = value.hour;\n        let wasPM = hours >= 12;\n        let isPM = segmentValue >= 12;\n        if (isPM === wasPM) {\n          return value;\n        }\n        return value.set({hour: wasPM ? hours - 12 : hours + 12});\n      }\n      case 'hour':\n        // In 12 hour time, ensure that AM/PM does not change\n        if (options.hour12) {\n          let hours = value.hour;\n          let wasPM = hours >= 12;\n          if (!wasPM && segmentValue === 12) {\n            segmentValue = 0;\n          }\n          if (wasPM && segmentValue < 12) {\n            segmentValue += 12;\n          }\n        }\n        // fallthrough\n      case 'minute':\n      case 'second':\n        return value.set({[part]: segmentValue});\n    }\n  }\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {LocalizedStringDictionary} from '@internationalized/string';\n\n// These placeholders are based on the strings used by the <input type=\"date\">\n// implementations in Chrome and Firefox. Additional languages are supported\n// here than React Spectrum's typical translations.\nconst placeholders = new LocalizedStringDictionary({\n  ach: {year: 'mwaka', month: 'dwe', day: 'nino'},\n  af: {year: 'jjjj', month: 'mm', day: 'dd'},\n  am: {year: 'ዓዓዓዓ', month: 'ሚሜ', day: 'ቀቀ'},\n  an: {year: 'aaaa', month: 'mm', day: 'dd'},\n  ar: {year: 'سنة', month: 'شهر', day: 'يوم'},\n  ast: {year: 'aaaa', month: 'mm', day: 'dd'},\n  az: {year: 'iiii', month: 'aa', day: 'gg'},\n  be: {year: 'гггг', month: 'мм', day: 'дд'},\n  bg: {year: 'гггг', month: 'мм', day: 'дд'},\n  bn: {year: 'yyyy', month: 'মিমি', day: 'dd'},\n  br: {year: 'bbbb', month: 'mm', day: 'dd'},\n  bs: {year: 'gggg', month: 'mm', day: 'dd'},\n  ca: {year: 'aaaa', month: 'mm', day: 'dd'},\n  cak: {year: 'jjjj', month: 'ii', day: \"q'q'\"},\n  ckb: {year: 'ساڵ', month: 'مانگ', day: 'ڕۆژ'},\n  cs: {year: 'rrrr', month: 'mm', day: 'dd'},\n  cy: {year: 'bbbb', month: 'mm', day: 'dd'},\n  da: {year: 'åååå', month: 'mm', day: 'dd'},\n  de: {year: 'jjjj', month: 'mm', day: 'tt'},\n  dsb: {year: 'llll', month: 'mm', day: 'źź'},\n  el: {year: 'εεεε', month: 'μμ', day: 'ηη'},\n  en: {year: 'yyyy', month: 'mm', day: 'dd'},\n  eo: {year: 'jjjj', month: 'mm', day: 'tt'},\n  es: {year: 'aaaa', month: 'mm', day: 'dd'},\n  et: {year: 'aaaa', month: 'kk', day: 'pp'},\n  eu: {year: 'uuuu', month: 'hh', day: 'ee'},\n  fa: {year: 'سال', month: 'ماه', day: 'روز'},\n  ff: {year: 'hhhh', month: 'll', day: 'ññ'},\n  fi: {year: 'vvvv', month: 'kk', day: 'pp'},\n  fr: {year: 'aaaa', month: 'mm', day: 'jj'},\n  fy: {year: 'jjjj', month: 'mm', day: 'dd'},\n  ga: {year: 'bbbb', month: 'mm', day: 'll'},\n  gd: {year: 'bbbb', month: 'mm', day: 'll'},\n  gl: {year: 'aaaa', month: 'mm', day: 'dd'},\n  he: {year: 'שנה', month: 'חודש', day: 'יום'},\n  hr: {year: 'gggg', month: 'mm', day: 'dd'},\n  hsb: {year: 'llll', month: 'mm', day: 'dd'},\n  hu: {year: 'éééé', month: 'hh', day: 'nn'},\n  ia: {year: 'aaaa', month: 'mm', day: 'dd'},\n  id: {year: 'tttt', month: 'bb', day: 'hh'},\n  it: {year: 'aaaa', month: 'mm', day: 'gg'},\n  ja: {year: ' 年 ', month: '月', day: '日'},\n  ka: {year: 'წწწწ', month: 'თთ', day: 'რრ'},\n  kk: {year: 'жжжж', month: 'аа', day: 'кк'},\n  kn: {year: 'ವವವವ', month: 'ಮಿಮೀ', day: 'ದಿದಿ'},\n  ko: {year: '연도', month: '월', day: '일'},\n  lb: {year: 'jjjj', month: 'mm', day: 'dd'},\n  lo: {year: 'ປປປປ', month: 'ດດ', day: 'ວວ'},\n  lt: {year: 'mmmm', month: 'mm', day: 'dd'},\n  lv: {year: 'gggg', month: 'mm', day: 'dd'},\n  meh: {year: 'aaaa', month: 'mm', day: 'dd'},\n  ml: {year: 'വർഷം', month: 'മാസം', day: 'തീയതി'},\n  ms: {year: 'tttt', month: 'mm', day: 'hh'},\n  nl: {year: 'jjjj', month: 'mm', day: 'dd'},\n  nn: {year: 'åååå', month: 'mm', day: 'dd'},\n  no: {year: 'åååå', month: 'mm', day: 'dd'},\n  oc: {year: 'aaaa', month: 'mm', day: 'jj'},\n  pl: {year: 'rrrr', month: 'mm', day: 'dd'},\n  pt: {year: 'aaaa', month: 'mm', day: 'dd'},\n  rm: {year: 'oooo', month: 'mm', day: 'dd'},\n  ro: {year: 'aaaa', month: 'll', day: 'zz'},\n  ru: {year: 'гггг', month: 'мм', day: 'дд'},\n  sc: {year: 'aaaa', month: 'mm', day: 'dd'},\n  scn: {year: 'aaaa', month: 'mm', day: 'jj'},\n  sk: {year: 'rrrr', month: 'mm', day: 'dd'},\n  sl: {year: 'llll', month: 'mm', day: 'dd'},\n  sr: {year: 'гггг', month: 'мм', day: 'дд'},\n  sv: {year: 'åååå', month: 'mm', day: 'dd'},\n  szl: {year: 'rrrr', month: 'mm', day: 'dd'},\n  tg: {year: 'сссс', month: 'мм', day: 'рр'},\n  th: {year: 'ปปปป', month: 'ดด', day: 'วว'},\n  tr: {year: 'yyyy', month: 'aa', day: 'gg'},\n  uk: {year: 'рррр', month: 'мм', day: 'дд'},\n  'zh-CN': {year: '年', month: '月', day: '日'},\n  'zh-TW': {year: '年', month: '月', day: '日'}\n}, 'en');\n\nexport function getPlaceholder(field: string, value: string, locale: string) {\n  // Use the actual placeholder value for the era and day period fields.\n  if (field === 'era' || field === 'dayPeriod') {\n    return value;\n  }\n\n  if (field === 'year' || field === 'month' || field === 'day') {\n    return placeholders.getStringForLocale(field, locale);\n  }\n\n  // For time fields (e.g. hour, minute, etc.), use two dashes as the placeholder.\n  return '––';\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DateFormatter, toCalendarDate, toCalendarDateTime} from '@internationalized/date';\nimport {DateRange, DateRangePickerProps, DateValue, Granularity, TimeValue} from '@react-types/datepicker';\nimport {FieldOptions, getFormatOptions, getPlaceholderTime, isInvalid, useDefaultProps} from './utils';\nimport {OverlayTriggerState, useOverlayTriggerState} from '@react-stately/overlays';\nimport {RangeValue, ValidationState} from '@react-types/shared';\nimport {useControlledState} from '@react-stately/utils';\nimport {useState} from 'react';\n\nexport interface DateRangePickerStateOptions<T extends DateValue = DateValue> extends DateRangePickerProps<T> {\n  /**\n   * Determines whether the date picker popover should close automatically when a date is selected.\n   * @default true\n   */\n  shouldCloseOnSelect?: boolean | (() => boolean)\n}\n\ntype TimeRange = RangeValue<TimeValue>;\nexport interface DateRangePickerState extends OverlayTriggerState {\n  /** The currently selected date range. */\n  value: DateRange,\n  /** Sets the selected date range. */\n  setValue(value: DateRange): void,\n  /**\n   * The date portion of the selected range. This may be set prior to `value` if the user has\n   * selected a date range but has not yet selected a time range.\n   */\n  dateRange: DateRange,\n  /** Sets the date portion of the selected range. */\n  setDateRange(value: DateRange): void,\n  /**\n   * The time portion of the selected range. This may be set prior to `value` if the user has\n   * selected a time range but has not yet selected a date range.\n   */\n  timeRange: TimeRange,\n  /** Sets the time portion of the selected range. */\n  setTimeRange(value: TimeRange): void,\n  /** Sets the date portion of either the start or end of the selected range. */\n  setDate(part: 'start' | 'end', value: DateValue): void,\n  /** Sets the time portion of either the start or end of the selected range. */\n  setTime(part: 'start' | 'end', value: TimeValue): void,\n  /** Sets the date and time of either the start or end of the selected range. */\n  setDateTime(part: 'start' | 'end', value: DateValue): void,\n  /** The granularity for the field, based on the `granularity` prop and current value. */\n  granularity: Granularity,\n  /** Whether the date range picker supports selecting times, according to the `granularity` prop and current value. */\n  hasTime: boolean,\n  /** Whether the calendar popover is currently open. */\n  isOpen: boolean,\n  /** Sets whether the calendar popover is open. */\n  setOpen(isOpen: boolean): void,\n  /** The current validation state of the date picker, based on the `validationState`, `minValue`, and `maxValue` props. */\n  validationState: ValidationState,\n  /** Formats the selected range using the given options. */\n  formatValue(locale: string, fieldOptions: FieldOptions): {start: string, end: string}\n}\n\n/**\n * Provides state management for a date range picker component.\n * A date range picker combines two DateFields and a RangeCalendar popover to allow\n * users to enter or select a date and time range.\n */\nexport function useDateRangePickerState<T extends DateValue = DateValue>(props: DateRangePickerStateOptions<T>): DateRangePickerState {\n  let overlayState = useOverlayTriggerState(props);\n  let [controlledValue, setControlledValue] = useControlledState<DateRange>(props.value, props.defaultValue || null, props.onChange);\n  let [placeholderValue, setPlaceholderValue] = useState(() => controlledValue || {start: null, end: null});\n\n  // Reset the placeholder if the value prop is set to null.\n  if (controlledValue == null && placeholderValue.start && placeholderValue.end) {\n    placeholderValue = {start: null, end: null};\n    setPlaceholderValue(placeholderValue);\n  }\n\n  let value = controlledValue || placeholderValue;\n\n  let setValue = (value: DateRange) => {\n    setPlaceholderValue(value);\n    if (value?.start && value.end) {\n      setControlledValue(value);\n    } else {\n      setControlledValue(null);\n    }\n  };\n\n  let v = (value?.start || value?.end || props.placeholderValue);\n  let [granularity] = useDefaultProps(v, props.granularity);\n  let hasTime = granularity === 'hour' || granularity === 'minute' || granularity === 'second';\n  let shouldCloseOnSelect = props.shouldCloseOnSelect ?? true;\n\n  let [dateRange, setSelectedDateRange] = useState<DateRange>(null);\n  let [timeRange, setSelectedTimeRange] = useState<TimeRange>(null);\n\n  if (value && value.start && value.end) {\n    dateRange = value;\n    if ('hour' in value.start) {\n      timeRange = value as TimeRange;\n    }\n  }\n\n  let commitValue = (dateRange: DateRange, timeRange: TimeRange) => {\n    setValue({\n      start: 'timeZone' in timeRange.start ? timeRange.start.set(toCalendarDate(dateRange.start)) : toCalendarDateTime(dateRange.start, timeRange.start),\n      end: 'timeZone' in timeRange.end ? timeRange.end.set(toCalendarDate(dateRange.end)) : toCalendarDateTime(dateRange.end, timeRange.end)\n    });\n    setSelectedDateRange(null);\n    setSelectedTimeRange(null);\n  };\n\n  // Intercept setValue to make sure the Time section is not changed by date selection in Calendar\n  let setDateRange = (range: DateRange) => {\n    let shouldClose = typeof shouldCloseOnSelect === 'function' ? shouldCloseOnSelect() : shouldCloseOnSelect;\n    if (hasTime) {\n      if (shouldClose || (range.start && range.end && timeRange?.start && timeRange?.end)) {\n        commitValue(range, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      } else {\n        setSelectedDateRange(range);\n      }\n    } else if (range.start && range.end) {\n      setValue(range);\n    } else {\n      setSelectedDateRange(range);\n    }\n\n    if (shouldClose) {\n      overlayState.setOpen(false);\n    }\n  };\n\n  let setTimeRange = (range: TimeRange) => {\n    if (dateRange?.start && dateRange?.end && range.start && range.end) {\n      commitValue(dateRange, range);\n    } else {\n      setSelectedTimeRange(range);\n    }\n  };\n\n  let validationState: ValidationState = props.validationState\n    || (value != null && (\n      isInvalid(value.start, props.minValue, props.maxValue) ||\n      isInvalid(value.end, props.minValue, props.maxValue) ||\n      (value.end != null && value.start != null && value.end.compare(value.start) < 0) ||\n      (value?.start && props.isDateUnavailable?.(value.start)) ||\n      (value?.end && props.isDateUnavailable?.(value.end))\n    ) ? 'invalid' : null);\n\n  return {\n    value,\n    setValue,\n    dateRange,\n    timeRange,\n    granularity,\n    hasTime,\n    setDate(part, date) {\n      setDateRange({...dateRange, [part]: date});\n    },\n    setTime(part, time) {\n      setTimeRange({...timeRange, [part]: time});\n    },\n    setDateTime(part, dateTime) {\n      setValue({...value, [part]: dateTime});\n    },\n    setDateRange,\n    setTimeRange,\n    ...overlayState,\n    setOpen(isOpen) {\n      // Commit the selected date range when the calendar is closed. Use a placeholder time if one wasn't set.\n      // If only the time range was set and not the date range, don't commit. The state will be preserved until\n      // the user opens the popover again.\n      if (!isOpen && !(value?.start && value?.end) && dateRange?.start && dateRange?.end && hasTime) {\n        commitValue(dateRange, {\n          start: timeRange?.start || getPlaceholderTime(props.placeholderValue),\n          end: timeRange?.end || getPlaceholderTime(props.placeholderValue)\n        });\n      }\n\n      overlayState.setOpen(isOpen);\n    },\n    validationState,\n    formatValue(locale, fieldOptions) {\n      if (!value || !value.start || !value.end) {\n        return null;\n      }\n\n      let startTimeZone = 'timeZone' in value.start ? value.start.timeZone : undefined;\n      let startGranularity = props.granularity || (value.start && 'minute' in value.start ? 'minute' : 'day');\n      let endTimeZone = 'timeZone' in value.end ? value.end.timeZone : undefined;\n      let endGranularity = props.granularity || (value.end && 'minute' in value.end ? 'minute' : 'day');\n\n      let startOptions = getFormatOptions(fieldOptions, {\n        granularity: startGranularity,\n        timeZone: startTimeZone,\n        hideTimeZone: props.hideTimeZone,\n        hourCycle: props.hourCycle,\n        showEra: (value.start.calendar.identifier === 'gregory' && value.start.era === 'BC') ||\n          (value.end.calendar.identifier === 'gregory' && value.end.era === 'BC')\n      });\n\n      let startDate = value.start.toDate(startTimeZone || 'UTC');\n      let endDate = value.end.toDate(endTimeZone || 'UTC');\n\n      let startFormatter = new DateFormatter(locale, startOptions);\n      let endFormatter: Intl.DateTimeFormat;\n      if (startTimeZone === endTimeZone && startGranularity === endGranularity && value.start.compare(value.end) !== 0) {\n        // Use formatRange, as it results in shorter output when some of the fields\n        // are shared between the start and end dates (e.g. the same month).\n        // Formatting will fail if the end date is before the start date. Fall back below when that happens.\n        try {\n          let parts = startFormatter.formatRangeToParts(startDate, endDate);\n\n          // Find the separator between the start and end date. This is determined\n          // by finding the last shared literal before the end range.\n          let separatorIndex = -1;\n          for (let i = 0; i < parts.length; i++) {\n            let part = parts[i];\n            if (part.source === 'shared' && part.type === 'literal') {\n              separatorIndex = i;\n            } else if (part.source === 'endRange') {\n              break;\n            }\n          }\n\n          // Now we can combine the parts into start and end strings.\n          let start = '';\n          let end = '';\n          for (let i = 0; i < parts.length; i++) {\n            if (i < separatorIndex) {\n              start += parts[i].value;\n            } else if (i > separatorIndex) {\n              end += parts[i].value;\n            }\n          }\n\n          return {start, end};\n        } catch (e) {\n          // ignore\n        }\n\n        endFormatter = startFormatter;\n      } else {\n        let endOptions = getFormatOptions(fieldOptions, {\n          granularity: endGranularity,\n          timeZone: endTimeZone,\n          hideTimeZone: props.hideTimeZone,\n          hourCycle: props.hourCycle\n        });\n\n        endFormatter = new DateFormatter(locale, endOptions);\n      }\n\n      return {\n        start: startFormatter.format(startDate),\n        end: endFormatter.format(endDate)\n      };\n    }\n  };\n}\n", "/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {DateFieldState, useDateFieldState} from '.';\nimport {DateValue, TimePickerProps, TimeValue} from '@react-types/datepicker';\nimport {getLocalTimeZone, GregorianCalendar, Time, toCalendarDateTime, today, toTime, toZoned} from '@internationalized/date';\nimport {useControlledState} from '@react-stately/utils';\nimport {useMemo} from 'react';\n\nexport interface TimeFieldStateOptions<T extends TimeValue = TimeValue> extends TimePickerProps<T> {\n  /** The locale to display and edit the value according to. */\n  locale: string\n}\n\nexport interface TimeFieldState extends DateFieldState {\n  /** The current time value. */\n  timeValue: Time\n}\n\n/**\n * Provides state management for a time field component.\n * A time field allows users to enter and edit time values using a keyboard.\n * Each part of a time value is displayed in an individually editable segment.\n */\nexport function useTimeFieldState<T extends TimeValue = TimeValue>(props: TimeFieldStateOptions<T>): TimeFieldState {\n  let {\n    placeholderValue = new Time(),\n    minValue,\n    maxValue,\n    granularity\n  } = props;\n\n  let [value, setValue] = useControlledState<TimeValue>(\n    props.value,\n    props.defaultValue,\n    props.onChange\n  );\n\n  let v = value || placeholderValue;\n  let day = v && 'day' in v ? v : undefined;\n  let defaultValueTimeZone = props.defaultValue && 'timeZone' in props.defaultValue ? props.defaultValue.timeZone : undefined;\n  let placeholderDate = useMemo(() => {\n    let valueTimeZone = v && 'timeZone' in v ? v.timeZone : undefined;\n\n    return (valueTimeZone || defaultValueTimeZone) && placeholderValue ? toZoned(convertValue(placeholderValue), valueTimeZone || defaultValueTimeZone) : convertValue(placeholderValue);\n  }, [placeholderValue, v, defaultValueTimeZone]);\n  let minDate = useMemo(() => convertValue(minValue, day), [minValue, day]);\n  let maxDate = useMemo(() => convertValue(maxValue, day), [maxValue, day]);\n\n  let timeValue = useMemo(() => value && 'day' in value ? toTime(value) : value as Time, [value]);\n  let dateTime = useMemo(() => value == null ? null : convertValue(value), [value]);\n  let onChange = newValue => {\n    setValue(day || defaultValueTimeZone ? newValue : newValue && toTime(newValue));\n  };\n\n  let state = useDateFieldState({\n    ...props,\n    value: dateTime,\n    defaultValue: undefined,\n    minValue: minDate,\n    maxValue: maxDate,\n    onChange,\n    granularity: granularity || 'minute',\n    maxGranularity: 'hour',\n    placeholderValue: placeholderDate,\n    // Calendar should not matter for time fields.\n    createCalendar: () => new GregorianCalendar()\n  });\n\n  return {\n    ...state,\n    timeValue\n  };\n}\n\nfunction convertValue(value: TimeValue, date: DateValue = today(getLocalTimeZone())) {\n  if (!value) {\n    return null;\n  }\n\n  if ('day' in value) {\n    return value;\n  }\n\n  return toCalendarDateTime(date, value);\n}\n"],
  "mappings": "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",
  "names": ["$4oA3P$useCallback", "opts", "$7UzoM$useState", "$7UzoM$useMemo", "$7UzoM$useRef", "$7UzoM$useEffect", "v", "value", "dateRange", "timeRange"]
}
